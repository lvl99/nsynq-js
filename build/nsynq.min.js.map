{"version":3,"sources":["nsynq.min.js"],"names":["Nsynq","timelineLength","ops","self","this","timeline","exp","gt","n","a","parseInt","gte","lt","lte","eq","is","within","range","split","outside","around","input","tolerance","per","approx","mod","renderTimeline","_ops","console","log","t","processExp","push","o","length","op","isTrue","x","checkExp","_exp","test","e","y","match","seek","module","exports"],"mappings":"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","file":"nsynq.min.js","sourcesContent":["/* *nsynq\n * Schedule JS operations along a timeline progression defined by `n`.\n *\n * @author Matt Scheurich <matt@lvl99.com>\n * @license MIT\n * @version 0.1.0-alpha\n */\n\n/*\nThe MIT License (MIT)\nCopyright (c) 2015 Matt Scheurich, http://www.lvl99.com\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the “Software”), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\nvar Nsynq = function ( timelineLength, ops ) {\n  var self = this;\n\n  /* The array which holds the rendered timeline information.\n   *\n   * @method timeline\n   * @type {array}\n   * @since 0.1.0-alpha\n   */\n  self.timeline = [];\n\n  /* The length of the timeline to render to.\n   *\n   * @method timelineLength\n   * @type {int}\n   * @since 0.1.0-alpha\n   */\n  self.timelineLength = 0;\n\n  /* The operations to fire at points on the timeline. Points are marked by\n   * string expressions.\n   *\n   * @method ops\n   * @type {object}\n   * @since 0.1.0-alpha\n   */\n  self.ops = {};\n\n  /* The expressions to match and set operations to point `n` on the timeline.\n   * Multiple expressions can be separated by `and` and `,`.\n   *\n   * @method exp\n   * @type {object}\n   * @since 0.1.0-alpha\n   */\n  self.exp = {\n    // `n gt 100` matches to `n > 100`\n    gt: function ( n, a ) {\n      return n > parseInt( a, 10 );\n    },\n\n    // `n gte 100` matches to `n >= 100`\n    gte: function ( n, a ) {\n      return n >= parseInt( a, 10 );\n    },\n\n    // `n lt 100` matches to `n < 100`\n    lt: function ( n, a ) {\n      return n < parseInt( a, 10 );\n    },\n\n    // `n lte 100` matches to `n >= 100`\n    lte: function ( n, a ) {\n      return n <= parseInt( a, 10 );\n    },\n\n    // `n eq 100` matches to `n == 100`\n    eq: function ( n, a ) {\n      return n == parseInt( a, 10 );\n    },\n\n    // `n is 100` matches to `n === 100`\n    is: function ( n, a ) {\n      return n === parseInt( a, 10 );\n    },\n\n    // `n within 100-200` matches to `n >= 100 && n <= 200`\n    within: function ( n, range ) {\n      range = range.split('-');\n      return ( n >= parseInt( range[0], 10 ) && n <= parseInt( range[1], 10 ) );\n    },\n\n    // `n outside 100-200` matches to `n < 100 || n > 200`\n    outside: function ( n, range ) {\n      range = range.split('-');\n      return ( n < parseInt( range[0], 10 ) || n > parseInt( range[1], 10 ) );\n    },\n\n    // `n around 1000:200` matches to `n >= 800 && n <= 1200`\n    around: function ( n, input ) {\n      var a, tolerance;\n\n      input = input.split( ':' );\n      a = parseInt( input[0], 10 );\n      tolerance = parseInt( input[1], 10 );\n\n      return ( n >= (a - tolerance) && n <= (a + tolerance) );\n    },\n\n    // `per 100 n` matches to `n % 100 === 0`\n    per: function ( n, a ) {\n      return n % parseInt( a, 10 ) === 0;\n    },\n\n    // `approx 100:5 n` matches to `n >= 95 && n <= 105`\n    approx: function ( n, input ) {\n      var a, tolerance, mod;\n\n      input = input.split( ':' );\n      a = parseInt( input[0], 10 );\n      tolerance = parseInt( input[1], 10 );\n      mod = n % a;\n\n      return ( mod >= (a - tolerance) || mod <= tolerance );\n    }\n  };\n\n  /* Renders the timeline using the operations and expressions from `self.ops`.\n   *\n   * @method renderTimeline\n   * @param {int} timelineLength The length of the timeline\n   * @param {object} ops An object containing multiple expressions as string\n   *                     keys to match `n` on the various points on the timeline\n   * @returns {void}\n   * @since 0.1.0-alpha\n   */\n  self.renderTimeline = function ( timelineLength, ops ) {\n    var timeline = [];\n    self.timelineLength = timelineLength;\n    self.ops = ops || self.ops;\n    self._ops = [];\n\n    // Ops in invalid or no timelineLength set, abort further actions\n    if ( !self.ops || !self.timelineLength ) {\n      if ( !self.ops ) console.log( 'No operations to render' );\n      if ( !self.timelineLength ) console.log( 'No timeline length to render to' );\n      return;\n    }\n\n    // Process each operation (defined by an expression key, e.g. `n eq 500`, `n within 100-200, do per 50 n`)\n    for ( var t in self.ops ) {\n      var exp = self.processExp( t, self.ops[t] );\n      self._ops.push( exp );\n    }\n\n    // Generate the timeline\n    for ( var n = 0; n <= self.timelineLength; n++ ) {\n      timeline[n] = [];\n\n      // Go through the operations to see if it can be added to the timeline at this point\n      for ( var o = 0; o < self._ops.length; o++ ) {\n        var op = self._ops[o];\n\n        // Process each expression to check if operation can be performed at this point in timeline\n        var isTrue = 0;\n        for ( var x = 0; x < op.exp.length; x++ ) {\n          var exp = op.exp[x];\n          if ( !self.checkExp(n, exp) ) {\n            break;\n          }\n          isTrue++;\n        }\n\n        // Only add if both expressions are true\n        // @todo support `or`\n        if ( isTrue === op.exp.length ) {\n          timeline[n].push( op.op );\n        }\n      }\n    }\n\n    self.timeline = timeline;\n  };\n\n  /* Process an expression to figure out when it fires on the timeline\n   * and what operation it fires.\n   *\n   * @method processExp\n   * @param {string} exp A string hash contained within `self.ops`\n   * @returns {object}\n   * @since 0.1.0-alpha\n   */\n  self.processExp = function ( exp, op ) {\n    var _exp = {};\n\n    // Multiple expressions given\n    if ( /,/.test(exp) ) {\n      exp = exp.split(/\\s*,\\s*/);\n\n    // Only one specified\n    } else {\n      exp = [ exp ];\n    }\n\n    // Process multiple expressions to match on\n    _exp.exp = [];\n    for ( var x = 0; x < exp.length; x++ ) {\n      var e = exp[x];\n\n      // Split by `and`\n      // @todo support `or`\n      if ( /and/.test(e) ) {\n        e = e.split('and');\n      } else {\n        e = [ e ];\n      }\n\n      // Get each expression\n      for ( var y = 0; y < e.length; y++ ) {\n        var match = e[y].match( /([^\\s]+) ([\\d-:]+)/ );\n        // match[1] == expression string hash in `self.exp` object\n        // match[2] == the number (or other string — effectively `n`) to match on the timeline\n        _exp.exp.push([match[1], match[2]]);\n      }\n    }\n\n    _exp.op = op;\n\n    return _exp;\n  };\n\n  /* Check if the expression can be fired at `n`.\n   *\n   * @method checkExp\n   * @param {int} n A point in the timeline\n   * @param {object} exp An object containing an expression's properties\n   * @returns {boolean}\n   * @since 0.1.0-alpha\n   */\n  self.checkExp = function ( n, exp ) {\n    if ( self.exp[exp[0]] ) {\n      return self.exp[exp[0]]( n, exp[1] );\n    }\n  };\n\n  /* Seek to point `n` on the timeline and fire any operations at that point.\n   *\n   * @method seek\n   * @param {int} n A point in the timeline to seek to\n   * @returns {void}\n   * @since 0.1.0-alpha\n   */\n  self.seek = function ( n ) {\n    var ops = self.timeline[n];\n\n    if ( ops && ops.length > 0 ) {\n      for ( var x = 0; x < ops.length; x++ ) {\n        ops[x]( n );\n      }\n    }\n  };\n\n  // Initialise ops on construct\n  if ( timelineLength && ops ) {\n    self.renderTimeline( timelineLength, ops );\n  }\n\n};\n\nvar module = module || {};\nmodule.exports = Nsynq;"],"sourceRoot":"/source/"}